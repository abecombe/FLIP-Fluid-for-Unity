#pragma kernel CalcVorticity
#pragma kernel ConfineVorticity

#include "../Common.hlsl"

float _VorticityEpsilon;

StructuredBuffer<float3> _GridVelocityBufferRead;
RWStructuredBuffer<float3> _GridVelocityBufferRW;

StructuredBuffer<float4> _GridVorticityBufferRead;
RWStructuredBuffer<float4> _GridVorticityBufferWrite;

[numthreads(128, 1, 1)]
void CalcVorticity(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    const uint c_id_xp = CellIndexToCellID(c_index + int3(-1, 0, 0));
    const uint c_id_xn = CellIndexToCellID(c_index + int3(1, 0, 0));
    const uint c_id_yp = CellIndexToCellID(c_index + int3(0, -1, 0));
    const uint c_id_yn = CellIndexToCellID(c_index + int3(0, 1, 0));
    const uint c_id_zp = CellIndexToCellID(c_index + int3(0, 0, -1));
    const uint c_id_zn = CellIndexToCellID(c_index + int3(0, 0, 1));

    float4 vorticity = 0;
    vorticity.zy += float2(1, -1) * _GridInvSpacing.x * (_GridVelocityBufferRead[c_id_xn].yz - _GridVelocityBufferRead[c_id_xp].yz);
    vorticity.xz += float2(1, -1) * _GridInvSpacing.y * (_GridVelocityBufferRead[c_id_yn].zx - _GridVelocityBufferRead[c_id_yp].zx);
    vorticity.yx += float2(1, -1) * _GridInvSpacing.z * (_GridVelocityBufferRead[c_id_zn].xy - _GridVelocityBufferRead[c_id_zp].xy);
    vorticity *= 0.5f;
    vorticity.w = length(vorticity.xyz);

    _GridVorticityBufferWrite[c_id] = vorticity;
}

[numthreads(128, 1, 1)]
void ConfineVorticity(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    const uint c_id_xp = CellIndexToCellID(c_index + int3(-1, 0, 0));
    const uint c_id_xn = CellIndexToCellID(c_index + int3(1, 0, 0));
    const uint c_id_yp = CellIndexToCellID(c_index + int3(0, -1, 0));
    const uint c_id_yn = CellIndexToCellID(c_index + int3(0, 1, 0));
    const uint c_id_zp = CellIndexToCellID(c_index + int3(0, 0, -1));
    const uint c_id_zn = CellIndexToCellID(c_index + int3(0, 0, 1));

    float3 div_vorticity;
    div_vorticity.x = _GridInvSpacing.x * (_GridVorticityBufferRead[c_id_xn].w - _GridVorticityBufferRead[c_id_xp].w);
    div_vorticity.y = _GridInvSpacing.y * (_GridVorticityBufferRead[c_id_yn].w - _GridVorticityBufferRead[c_id_yp].w);
    div_vorticity.z = _GridInvSpacing.z * (_GridVorticityBufferRead[c_id_zn].w - _GridVorticityBufferRead[c_id_zp].w);
    div_vorticity *= 0.5f;

    const float3 N = div_vorticity / (length(div_vorticity) + 1e-20);
    const float3 force = _VorticityEpsilon * _GridSpacing * cross(N, _GridVorticityBufferRead[c_id].xyz);

    float3 velocity = _GridVelocityBufferRW[c_id];

    velocity += force * _DeltaTime;

    _GridVelocityBufferRW[c_id] = velocity;
}