#pragma kernel AdvectVelocity
#pragma kernel AdvectVelocityMacCormack
#pragma kernel AdvectVelocityBFECC
#pragma kernel AdvectScalar
#pragma kernel AdvectScalarMacCormack
#pragma kernel AdvectScalarBFECC

#define USE_LINEAR_KERNEL

#include "../Common.hlsl"
#include "../GridParamsSampling.hlsl"

StructuredBuffer<float3> _GridVelocityBufferRead;
StructuredBuffer<float> _GridScalarBufferRead;

RWStructuredBuffer<float3> _GridVelocityBufferWrite;
RWStructuredBuffer<float> _GridScalarBufferWrite;

float _Dissipation;
float _DissipationTarget;

[numthreads(128, 1, 1)]
void AdvectVelocity(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    const float3 position = CellIndexToWorldPos(c_index);

    const float3 back_traced_pos = position - SampleGridParam(position, _GridVelocityBufferRead) * _DeltaTime;

    const float3 velocity = SampleGridParam(back_traced_pos, _GridVelocityBufferRead);

    _GridVelocityBufferWrite[c_id] = velocity;
}

[numthreads(128, 1, 1)]
void AdvectVelocityMacCormack(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    const float3 position = CellIndexToWorldPos(c_index);

    const float3 back_traced_pos = position - SampleGridParam(position, _GridVelocityBufferRead) * _DeltaTime;
    const float3 forward_traced_pos = back_traced_pos + SampleGridParam(back_traced_pos, _GridVelocityBufferRead) * _DeltaTime;
    const float3 pos_error = (forward_traced_pos - position) * 0.5f;
    const float3 corrected_back_traced_pos = back_traced_pos - pos_error;

    const float3 velocity = SampleGridParam(corrected_back_traced_pos, _GridVelocityBufferRead);

    _GridVelocityBufferWrite[c_id] = velocity;
}

[numthreads(128, 1, 1)]
void AdvectVelocityBFECC(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    const float3 position = CellIndexToWorldPos(c_index);

    const float3 back_traced_pos = position - SampleGridParam(position, _GridVelocityBufferRead) * _DeltaTime;
    const float3 forward_traced_pos = back_traced_pos + SampleGridParam(back_traced_pos, _GridVelocityBufferRead) * _DeltaTime;
    const float3 pos_error = (forward_traced_pos - position) * 0.5f;
    const float3 corrected_pos = position - pos_error;
    const float3 corrected_back_traced_pos = corrected_pos - SampleGridParam(corrected_pos, _GridVelocityBufferRead) * _DeltaTime;

    const float3 velocity = SampleGridParam(corrected_back_traced_pos, _GridVelocityBufferRead);

    _GridVelocityBufferWrite[c_id] = velocity;
}

[numthreads(128, 1, 1)]
void AdvectScalar(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    const float3 position = CellIndexToWorldPos(c_index);

    const float3 back_traced_pos = position - SampleGridParam(position, _GridVelocityBufferRead) * _DeltaTime;

    float scalar = SampleGridParam(back_traced_pos, _GridScalarBufferRead);

    scalar = (scalar - _DissipationTarget) * _Dissipation + _DissipationTarget;

    _GridScalarBufferWrite[c_id] = scalar;
}

[numthreads(128, 1, 1)]
 void AdvectScalarMacCormack(uint3 thread_id : SV_DispatchThreadID)
 {
     RETURN_IF_INVALID(thread_id);
 
     const uint c_id = thread_id.x;
     const int3 c_index = CellIDToCellIndex(c_id);

     const float3 position = CellIndexToWorldPos(c_index);

     const float3 back_traced_pos = position - SampleGridParam(position, _GridVelocityBufferRead) * _DeltaTime;
     const float3 forward_traced_pos = back_traced_pos + SampleGridParam(back_traced_pos, _GridVelocityBufferRead) * _DeltaTime;
     const float3 pos_error = (forward_traced_pos - position) * 0.5f;
     const float3 corrected_back_traced_pos = back_traced_pos - pos_error;
 
    float scalar = SampleGridParam(corrected_back_traced_pos, _GridScalarBufferRead);

    scalar = (scalar - _DissipationTarget) * _Dissipation + _DissipationTarget;

    _GridScalarBufferWrite[c_id] = scalar;
 }

[numthreads(128, 1, 1)]
void AdvectScalarBFECC(uint3 thread_id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(thread_id);

    const uint c_id = thread_id.x;
    const int3 c_index = CellIDToCellIndex(c_id);

    const float3 position = CellIndexToWorldPos(c_index);

    const float3 back_traced_pos = position - SampleGridParam(position, _GridVelocityBufferRead) * _DeltaTime;
    const float3 forward_traced_pos = back_traced_pos + SampleGridParam(back_traced_pos, _GridVelocityBufferRead) * _DeltaTime;
    const float3 pos_error = (forward_traced_pos - position) * 0.5f;
    const float3 corrected_pos = position - pos_error;
    const float3 corrected_back_traced_pos = corrected_pos - SampleGridParam(corrected_pos, _GridVelocityBufferRead) * _DeltaTime;

    float scalar = SampleGridParam(corrected_back_traced_pos, _GridScalarBufferRead);

    scalar = (scalar - _DissipationTarget) * _Dissipation + _DissipationTarget;

    _GridScalarBufferWrite[c_id] = scalar;
}