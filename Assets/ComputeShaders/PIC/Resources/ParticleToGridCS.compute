#pragma kernel ParticleToGrid

#pragma multi_compile _ USE_LINEAR_KERNEL USE_QUADRATIC_KERNEL

#include "../Common.hlsl"

StructuredBuffer<Particle> _ParticleBufferRead;

StructuredBuffer<uint2> _GridParticleIDBufferRead;

RWStructuredBuffer<uint> _GridTypeBufferWrite;

RWStructuredBuffer<float3> _GridVelocityBufferWrite;
RWStructuredBuffer<float3> _GridOriginalVelocityBufferWrite;

#if defined(USE_LINEAR_KERNEL)
static const int gridRange[6] = { -1, 1, -1, 1, -1, 1 };
#elif defined(USE_QUADRATIC_KERNEL)
static const int gridRange[6] = { -1, 1, -1, 1, -1, 1 };
#else
static const int gridRange[6] = { 0, 0, 0, 0, 0, 0 };
#endif

[numthreads(128, 1, 1)]
void ParticleToGrid(uint3 id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(id);

    const uint c_id = id.x;
    const uint3 c_index = CellIDToCellIndex(c_id);

    // decide grid type
    const uint2 particle_index = _GridParticleIDBufferRead[c_id];
    _GridTypeBufferWrite[c_id] = particle_index.y - particle_index.x > 0 ? GT_FLUID : GT_AIR;

    const float3 position = CellIndexToCellPos(c_index);

    float sum_weight = 0;
    float3 sum_velocity = 0;

    // calc weight & velocity
    FOR_EACH_NEIGHBOR_CELL_PARTICLE_START(c_index, p_id, _GridParticleIDBufferRead, gridRange)
    {
        const Particle p = _ParticleBufferRead[p_id];

        const float weight = GetWeight(p.position, position, _GridInvSpacing);

        sum_weight += weight;
        sum_velocity += weight * p.velocity;
    }
    FOR_EACH_NEIGHBOR_CELL_PARTICLE_END

    const float3 velocity = sum_weight > 0 ? sum_velocity / max(sum_weight, FLT_MIN) : 0.0f;

    _GridVelocityBufferWrite[c_id] = velocity;
    _GridOriginalVelocityBufferWrite[c_id] = velocity;
}
