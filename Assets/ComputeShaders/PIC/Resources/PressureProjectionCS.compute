#pragma kernel CalcDivergence
#pragma kernel Project
#pragma kernel UpdateVelocity

#include "../Common.hlsl"

float3 _DivergenceParameter;
float4 _PressureProjectionParameter1;
float3 _PressureProjectionParameter2;

StructuredBuffer<uint> _GridTypeBufferRead;

StructuredBuffer<float3> _GridVelocityBufferRead;
RWStructuredBuffer<float3> _GridVelocityBufferRW;

StructuredBuffer<float> _GridDivergenceBufferRead;
RWStructuredBuffer<float> _GridDivergenceBufferWrite;

StructuredBuffer<float> _GridPressureBufferRead;
RWStructuredBuffer<float> _GridPressureBufferWrite;

[numthreads(128, 1, 1)]
void CalcDivergence(uint3 id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(id);

    const uint c_id = id.x;
    const uint3 c_index = CellIDToCellIndex(c_id);

    float divergence = 0;

    if (_GridTypeBufferRead[c_id] == GT_FLUID)
    {
        const uint c_id_xp = CellIndexToCellID(c_index + int3(-1, 0, 0));
        const uint c_id_xn = CellIndexToCellID(c_index + int3(1, 0, 0));
        const uint c_id_yp = CellIndexToCellID(c_index + int3(0, -1, 0));
        const uint c_id_yn = CellIndexToCellID(c_index + int3(0, 1, 0));
        const uint c_id_zp = CellIndexToCellID(c_index + int3(0, 0, -1));
        const uint c_id_zn = CellIndexToCellID(c_index + int3(0, 0, 1));

        divergence += _DivergenceParameter.x * (_GridVelocityBufferRead[c_id_xn].x - _GridVelocityBufferRead[c_id_xp].x);
        divergence += _DivergenceParameter.y * (_GridVelocityBufferRead[c_id_yn].y - _GridVelocityBufferRead[c_id_yp].y);
        divergence += _DivergenceParameter.z * (_GridVelocityBufferRead[c_id_zn].z - _GridVelocityBufferRead[c_id_zp].z);
    }

    _GridDivergenceBufferWrite[c_id] = divergence;
}

[numthreads(128, 1, 1)]
void Project(uint3 id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(id);

    const uint c_id = id.x;
    const uint3 c_index = CellIDToCellIndex(c_id);

    float pressure = 0;

    if (_GridTypeBufferRead[c_id] == GT_FLUID)
    {
        // project using Jacobi iterations
        const uint c_id_xp = CellIndexToCellID(c_index + int3(-1, 0, 0));
        const uint c_id_xn = CellIndexToCellID(c_index + int3(1, 0, 0));
        const uint c_id_yp = CellIndexToCellID(c_index + int3(0, -1, 0));
        const uint c_id_yn = CellIndexToCellID(c_index + int3(0, 1, 0));
        const uint c_id_zp = CellIndexToCellID(c_index + int3(0, 0, -1));
        const uint c_id_zn = CellIndexToCellID(c_index + int3(0, 0, 1));

        pressure += _PressureProjectionParameter1.x * (_GridPressureBufferRead[c_id_xp] + _GridPressureBufferRead[c_id_xn]);
        pressure += _PressureProjectionParameter1.y * (_GridPressureBufferRead[c_id_yp] + _GridPressureBufferRead[c_id_yn]);
        pressure += _PressureProjectionParameter1.z * (_GridPressureBufferRead[c_id_zp] + _GridPressureBufferRead[c_id_zn]);
        pressure += _PressureProjectionParameter1.w * _GridDivergenceBufferRead[c_id];
    }

    _GridPressureBufferWrite[c_id] = pressure;
}

[numthreads(128, 1, 1)]
void UpdateVelocity(uint3 id : SV_DispatchThreadID)
{
    RETURN_IF_INVALID(id);

    const uint c_id = id.x;
    const uint3 c_index = CellIDToCellIndex(c_id);

    const uint c_id_xp = CellIndexToCellID(c_index + int3(-1, 0, 0));
    const uint c_id_xn = CellIndexToCellID(c_index + int3(1, 0, 0));
    const uint c_id_yp = CellIndexToCellID(c_index + int3(0, -1, 0));
    const uint c_id_yn = CellIndexToCellID(c_index + int3(0, 1, 0));
    const uint c_id_zp = CellIndexToCellID(c_index + int3(0, 0, -1));
    const uint c_id_zn = CellIndexToCellID(c_index + int3(0, 0, 1));

    float3 velocity = _GridVelocityBufferRW[c_id];

    velocity.x -= _PressureProjectionParameter2.x * (_GridPressureBufferRead[c_id_xn] - _GridPressureBufferRead[c_id_xp]);
    velocity.y -= _PressureProjectionParameter2.y * (_GridPressureBufferRead[c_id_yn] - _GridPressureBufferRead[c_id_yp]);
    velocity.z -= _PressureProjectionParameter2.z * (_GridPressureBufferRead[c_id_zn] - _GridPressureBufferRead[c_id_zp]);

    _GridVelocityBufferRW[c_id] = velocity;
}